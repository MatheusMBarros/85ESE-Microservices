name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        service: [agenda-service, auth-service, user-service, api-gateway]

    env:
      REGISTRY: docker.io/mbarros01
      NODE_VERSION: 18

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm' # Adiciona cache para dependências npm, acelerando builds futuros

      - name: Install dependencies (${{ matrix.service }})
        working-directory: ${{ matrix.service }}
        run: npm install
        # Adicione um 'if: always()' se quiser que esta etapa seja executada mesmo após falhas anteriores
        # mas geralmente, se o npm install falhar, as próximas etapas não farão sentido.

      - name: Run tests (${{ matrix.service }})
        working-directory: ${{ matrix.service }}
        run: npm test
        # É crucial rodar os testes antes de construir a imagem Docker.
        # Se os testes falharem, o build não prosseguirá, economizando tempo e recursos.

      - name: Build service (${{ matrix.service }})
        working-directory: ${{ matrix.service }}
        run: npm run build
        # Muitos projetos Node.js precisam de uma etapa de build (ex: transpilação, bundling).
        # Se o seu projeto tiver um script 'build' no package.json, adicione esta etapa.
        # Caso contrário, remova-a.

      - name: Build Docker image (${{ matrix.service }})
        run: |
          # Verifica se o Dockerfile existe antes de tentar construir
          if [ -f "${{ matrix.service }}/Dockerfile" ]; then
            docker build -t $REGISTRY/${{ matrix.service }}:${{ github.sha }} ${{ matrix.service }}
          else
            echo "Dockerfile not found in ${{ matrix.service }}/. Skipping Docker build for this service."
            exit 1 # Falha a etapa se o Dockerfile não for encontrado, pois é essencial para o deploy
          fi
        # Se o 'docker build' falhar, verifique os logs para erros dentro do Dockerfile,
        # especialmente comandos como 'npm install' ou 'npm run build' que podem estar duplicados
        # ou falhando dentro do container.

      - name: Docker Login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Push Docker image (${{ matrix.service }})
        run: |
          docker push $REGISTRY/${{ matrix.service }}:${{ github.sha }}
          docker tag $REGISTRY/${{ matrix.service }}:${{ github.sha }} $REGISTRY/${{ matrix.service }}:latest
          docker push $REGISTRY/${{ matrix.service }}:latest

      - name: Upload Swagger YAML (${{ matrix.service }})
        uses: actions/upload-artifact@v4
        with:
          name: swagger-${{ matrix.service }}
          path: ${{ matrix.service }}/swagger.yaml
        continue-on-error: true # Permite que o pipeline continue mesmo se o swagger.yaml não for encontrado.
        # Se o swagger.yaml for gerado durante a etapa de 'build', certifique-se de que esta etapa
        # esteja após a etapa de 'build' para garantir que o arquivo exista.
        # Verifique se o caminho '${{ matrix.service }}/swagger.yaml' está correto.

      - name: SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: ${{ matrix.service }}
          args: >
            -Dsonar.projectKey= matheusmbarros
            -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }}
            -Dsonar.host.url=https://sonarcloud.io
            -Dsonar.qualitygate.wait=true